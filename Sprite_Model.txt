#pragma once

#include <Windows.h>
#include <cassert>
#include <d3d12.h>
#include <string>
#include <vector>
#include <wrl.h>

#include "DirectXCommon.h"
#include "Matrix.h" // Matrix4x4 用
#include "Method.h" // 行列計算関数（MakeAffineMatrixなど）
#include "ResourceManager.h"
#include "UnifiedPipeline.h"
#include "Vector.h" // Vector2, Vector3, Vector4 用

class Sprite {
public:
  struct CreateInfo {
    DirectXCommon *dx = nullptr;
    UnifiedPipeline *pipeline = nullptr;
    ResourceManager *resourceManager = nullptr;
    std::string texturePath;
    Vector2 size = {640, 360};
    Vector4 color = {1, 1, 1, 1};
  };

  bool Initialize(const CreateInfo &info);
  void SetPosition(const Vector3 &pos);
  void SetScale(const Vector3 &scale);
  void SetRotation(const Vector3 &rot);
  void SetUVTransform(const Matrix4x4 &uv);
  void SetColor(const Vector4 &color);
  void Draw(const Matrix4x4 &view, const Matrix4x4 &proj);

private:
  // 省略しない ComPtr エイリアス
  template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

private:
  ComPtr<ID3D12Resource> texture_;

  DirectXCommon *dx_ = nullptr;
  UnifiedPipeline *pipeline_ = nullptr;
  ResourceManager *resourceManager_ = nullptr;

  ComPtr<ID3D12Resource> vertexBuffer_;
  D3D12_VERTEX_BUFFER_VIEW vbView_{};
  ComPtr<ID3D12Resource> indexBuffer_;
  D3D12_INDEX_BUFFER_VIEW ibView_{};
  ComPtr<ID3D12Resource> materialBuffer_;
  ComPtr<ID3D12Resource> transformBuffer_;

  D3D12_GPU_DESCRIPTOR_HANDLE textureHandle_{};

  Matrix4x4 worldMatrix_ = MakeIdentity4x4();
  Vector3 position_{0, 0, 0};
  Vector3 scale_{1, 1, 1};
  Vector3 rotation_{0, 0, 0};
  Matrix4x4 uvMatrix_ = MakeIdentity4x4(); // UV用行列
  Vector4 color_ = {1, 1, 1, 1};           // マテリアルカラー
};



#include "Sprite.h"
#include "TextureUtils.h"
#include "externals/DirectXTex/DirectXTex.h"
#include <cassert>
#include <string>

struct SpriteVertex {
  Vector3 pos; // POSITION
  Vector2 uv;  // TEXCOORD
};

struct SpriteMaterial {
  Vector4 color;
  Matrix4x4 uvTransform; // 余計な int/pad は入れない
};

struct SpriteTransform {
  Matrix4x4 WVP;
  Matrix4x4 World;
};

constexpr UINT Align256(UINT n) { return (n + 255) & ~255; }

// ✅ テクスチャリソース作成
Microsoft::WRL::ComPtr<ID3D12Resource>
CreateTextureResource(ID3D12Device *device,
                      const DirectX::TexMetadata &metadata) {
  D3D12_RESOURCE_DESC desc{};
  desc.Width = static_cast<UINT>(metadata.width);
  desc.Height = static_cast<UINT>(metadata.height);
  desc.MipLevels = static_cast<UINT16>(metadata.mipLevels);
  desc.DepthOrArraySize = static_cast<UINT16>(metadata.arraySize);
  desc.Format = metadata.format;
  desc.SampleDesc.Count = 1;
  desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;

  // ←★ WriteBack + GenericRead で作る
  D3D12_HEAP_PROPERTIES heap{};
  heap.Type = D3D12_HEAP_TYPE_CUSTOM;
  heap.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
  heap.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;

  Microsoft::WRL::ComPtr<ID3D12Resource> tex;
  HRESULT hr = device->CreateCommittedResource(
      &heap, D3D12_HEAP_FLAG_NONE, &desc,
      D3D12_RESOURCE_STATE_GENERIC_READ, // ← SRVにそのまま使える
      nullptr, IID_PPV_ARGS(&tex));
  assert(SUCCEEDED(hr));
  return tex;
}

// GPUバッファ（頂点・インデックス・CB用）を作る汎用関数
Microsoft::WRL::ComPtr<ID3D12Resource>
CreateBufferResource(ID3D12Device *device, size_t sizeInBytes) {

  D3D12_HEAP_PROPERTIES heapProps{};
  heapProps.Type = D3D12_HEAP_TYPE_UPLOAD;

  D3D12_RESOURCE_DESC resourceDesc{};
  resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
  resourceDesc.Width = sizeInBytes;
  resourceDesc.Height = 1;
  resourceDesc.DepthOrArraySize = 1;
  resourceDesc.MipLevels = 1;
  resourceDesc.SampleDesc.Count = 1;
  resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

  Microsoft::WRL::ComPtr<ID3D12Resource> buffer;
  HRESULT hr = device->CreateCommittedResource(
      &heapProps, D3D12_HEAP_FLAG_NONE, &resourceDesc,
      D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(&buffer));
  assert(SUCCEEDED(hr));
  return buffer;
}

// ✅ 仮の UploadTextureData（実際の転送は未実装でもOK）
void UploadTextureData(ID3D12Resource *tex,
                       const DirectX::ScratchImage &mipImages) {
  const DirectX::TexMetadata &meta = mipImages.GetMetadata();
  for (size_t mip = 0; mip < meta.mipLevels; ++mip) {
    const DirectX::Image *img = mipImages.GetImage(mip, 0, 0);
    // WriteBack ヒープなのでこれで直接書ける
    HRESULT hr = tex->WriteToSubresource(
        static_cast<UINT>(mip), nullptr, img->pixels,
        static_cast<UINT>(img->rowPitch), static_cast<UINT>(img->slicePitch));
    assert(SUCCEEDED(hr));
  }
}

bool Sprite::Initialize(const CreateInfo &info) {
  dx_ = info.dx;
  pipeline_ = info.pipeline;
  resourceManager_ = info.resourceManager;
  color_ = info.color;

  // テクスチャ読み込み
  DirectX::ScratchImage mipImages = LoadTexture(info.texturePath);
  const DirectX::TexMetadata &metadata = mipImages.GetMetadata();
  texture_ = CreateTextureResource(dx_->GetDevice(), metadata);
  UploadTextureData(texture_.Get(), mipImages);

  // SRVを作成
  UINT texIdx = srvAlloc_->Allocate();
  D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
  srvDesc.Format = metadata.format;
  srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
  srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
  srvDesc.Texture2D.MipLevels = static_cast<UINT>(metadata.mipLevels);
  dx_->GetDevice()->CreateShaderResourceView(texture_.Get(), &srvDesc,
                                             srvAlloc_->Cpu(texIdx));
  textureHandle_ = srvAlloc_->Gpu(texIdx);

  // 頂点バッファ
  SpriteVertex vertices[4] = {
      {{0, info.size.y, 0}, {0, 1}},
      {{0, 0, 0}, {0, 0}},
      {{info.size.x, info.size.y, 0}, {1, 1}},
      {{info.size.x, 0, 0}, {1, 0}},
  };

  vertexBuffer_ = CreateBufferResource(dx_->GetDevice(), sizeof(vertices));
  void *vData = nullptr;
  vertexBuffer_->Map(0, nullptr, &vData);
  memcpy(vData, vertices, sizeof(vertices));
  vbView_.BufferLocation = vertexBuffer_->GetGPUVirtualAddress();
  vbView_.SizeInBytes = sizeof(vertices);
  vbView_.StrideInBytes = sizeof(SpriteVertex);

  // インデックスバッファ
  uint32_t indices[6] = {0, 1, 2, 1, 3, 2};
  indexBuffer_ = CreateBufferResource(dx_->GetDevice(), sizeof(indices));
  uint32_t *iData = nullptr;
  indexBuffer_->Map(0, nullptr, reinterpret_cast<void **>(&iData));
  memcpy(iData, indices, sizeof(indices));
  ibView_.BufferLocation = indexBuffer_->GetGPUVirtualAddress();
  ibView_.SizeInBytes = sizeof(indices);
  ibView_.Format = DXGI_FORMAT_R32_UINT;

  // マテリアル
  materialBuffer_ =
      CreateBufferResource(dx_->GetDevice(), Align256(sizeof(SpriteMaterial)));
  SpriteMaterial *mData = nullptr;
  materialBuffer_->Map(0, nullptr, reinterpret_cast<void **>(&mData));
  mData->color = color_;
  mData->uvTransform = uvMatrix_;

  // Transform
  transformBuffer_ =
      CreateBufferResource(dx_->GetDevice(), Align256(sizeof(SpriteTransform)));
  SpriteTransform *tData = nullptr;
  transformBuffer_->Map(0, nullptr, reinterpret_cast<void **>(&tData));
  tData->WVP = MakeIdentity4x4();
  tData->World = worldMatrix_; 

  return true;
}

void Sprite::SetPosition(const Vector3 &pos) { position_ = pos; }
void Sprite::SetScale(const Vector3 &scale) { scale_ = scale; }
void Sprite::SetRotation(const Vector3 &rot) { rotation_ = rot; }
void Sprite::SetUVTransform(const Matrix4x4 &uv) { uvMatrix_ = uv; }
void Sprite::SetColor(const Vector4 &color) { color_ = color; }

void Sprite::Draw(const Matrix4x4 &view, const Matrix4x4 &proj) {
  worldMatrix_ = MakeAffineMatrix(scale_, rotation_, position_);
  Matrix4x4 wvp = Multiply(worldMatrix_, Multiply(view, proj));
  {
    SpriteTransform *tData = nullptr;
    transformBuffer_->Map(0, nullptr, reinterpret_cast<void **>(&tData));
    tData->WVP = wvp;
    tData->World = worldMatrix_;
  }

  {
    SpriteMaterial *mData = nullptr;
    materialBuffer_->Map(0, nullptr, reinterpret_cast<void **>(&mData));
    mData->color = color_;
    mData->uvTransform = uvMatrix_;
  }

  ID3D12GraphicsCommandList *cmd = dx_->GetCommandList();
  ID3D12DescriptorHeap *heaps[] = {dx_->GetSRVHeap()};
  cmd->SetDescriptorHeaps(1, heaps);
  cmd->SetGraphicsRootSignature(pipeline_->GetRootSignature());
  cmd->SetPipelineState(pipeline_->GetPipelineState());
  cmd->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
  cmd->IASetVertexBuffers(0, 1, &vbView_);
  cmd->IASetIndexBuffer(&ibView_);

  cmd->SetGraphicsRootConstantBufferView(
      0, materialBuffer_->GetGPUVirtualAddress()); // PS:b0
  cmd->SetGraphicsRootConstantBufferView(
      1, transformBuffer_->GetGPUVirtualAddress()); // VS:b0
  cmd->SetGraphicsRootDescriptorTable(1, textureHandle_);

  cmd->DrawIndexedInstanced(6, 1, 0, 0, 0);
}





#pragma once
#include "DirectXCommon.h" // デバイス/コマンド/ヒープ類
#include "Matrix.h"        // Matrix4x4 用
#include "Method.h"        // 行列計算関数（MakeAffineMatrixなど）
#include "ResourceManager.h"
#include "UnifiedPipeline.h" // RootSig / PSO
#include "Vector.h"          // Vector2, Vector3, Vector4 用
#include <assert.h>
#include <d3d12.h>
#include <string>
#include <vector>
#include <wrl.h>

struct VertexData {
  Vector4 position;
  Vector2 texcoord;
  Vector3 normal;
};

struct Material {
  Vector4 color;          // RGBA
  int32_t enableLighting; // 0=Unlit,1=Lambert,2=HalfLambert
  float pad[3];
  Matrix4x4 uvTransform;
};

struct Transformation {
  Matrix4x4 WVP;
  Matrix4x4 World;
};

struct DirectionalLight {
  Vector4 color;
  Vector3 direction;
  float intensity;
};

// 既存の OBJ ローダが返すものを流用
struct MaterialData {
  std::string textureFilePath;
};

struct ModelData {
  std::vector<VertexData> vertices;
  MaterialData material;
};

class Model {
public:
  // 作成に必要な情報をまとめる
  struct CreateInfo {
    DirectXCommon *dx = nullptr; // デバイス/コマンド/ヒープへのアクセス
    UnifiedPipeline *pipeline = nullptr; // 使用するPSO（Object3D用）
    ResourceManager *resourceManager = nullptr;
    ModelData modelData; // 頂点配列 & マテリアル（テクスチャパス等）
    Vector4 baseColor{1, 1, 1, 1}; // デフォルト色
    int32_t lightingMode = 1;      // 0/1/2（PSの分岐と一致）
  };

public:
  bool Initialize(const CreateInfo &info);
  void SetColor(const Vector4 &color);
  void SetLightingMode(int32_t mode); // 0=Unlit, 1=Lambert, 2=HalfLambert
  void SetUVTransform(const Matrix4x4 &uv);
  void SetWorldTransform(const Matrix4x4 &world);

  // view/proj と ライトCB の GPU アドレスは呼び出し側から（共通）渡す
  void Draw(const Matrix4x4 &view, const Matrix4x4 &proj,
            ID3D12Resource *directionalLightCB);

private:
  // 省略しない ComPtr エイリアス
  template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

  // ヘルパ
  ComPtr<ID3D12Resource> CreateUploadBuffer(size_t size);

private:
  // 参照
  DirectXCommon *dx_ = nullptr;
  UnifiedPipeline *pipeline_ = nullptr;
  ResourceManager *resourceManager_ = nullptr;

  // リソース
  ComPtr<ID3D12Resource> vb_;
  D3D12_VERTEX_BUFFER_VIEW vbv_{};
  ComPtr<ID3D12Resource> cbMaterial_;
  Material *cbMatMapped_ = nullptr;
  ComPtr<ID3D12Resource> cbTransform_;
  Transformation *cbTransMapped_ = nullptr;
  ComPtr<ID3D12Resource> tex_;
  D3D12_GPU_DESCRIPTOR_HANDLE texHandleGPU_{};

  // 行列
  Matrix4x4 world_ = MakeIdentity4x4();
};





#include "Model.h"
#include "ResourceManager.h"
#include "externals/DirectXTex/DirectXTex.h"

// 既存のヘルパ（あなたの環境にある実装を使用）
extern DirectX::ScratchImage LoadTexture(const std::string &filePath);

constexpr UINT Align256(UINT n) { return (n + 255) & ~255; }

// ===== SrvAllocator 実装（mainと同一の挙動） =====
void SrvAllocator::Init(ID3D12Device *dev, ID3D12DescriptorHeap *h) {
  device = dev;
  heap = h;
  inc = device->GetDescriptorHandleIncrementSize(
      D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
  next = 1; // 0はImGui
}
UINT SrvAllocator::Allocate() { return next++; }
D3D12_CPU_DESCRIPTOR_HANDLE SrvAllocator::Cpu(UINT index) const {
  D3D12_CPU_DESCRIPTOR_HANDLE base = heap->GetCPUDescriptorHandleForHeapStart();
  base.ptr += size_t(index) * inc;
  return base;
}
D3D12_GPU_DESCRIPTOR_HANDLE SrvAllocator::Gpu(UINT index) const {
  D3D12_GPU_DESCRIPTOR_HANDLE base = heap->GetGPUDescriptorHandleForHeapStart();
  base.ptr += size_t(index) * inc;
  return base;
}

// ===== Model 実装 =====
bool Model::Initialize(const CreateInfo &info) {
  assert(info.dx && info.pipeline && info.resourceManager);
  dx_ = info.dx;
  pipeline_ = info.pipeline;
  resourceManager_ = info.resourceManager;

  ID3D12Device *device = dx_->GetDevice();
  ID3D12GraphicsCommandList *cmd = dx_->GetCommandList();

  // 頂点バッファ
  vb_ = CreateUploadBuffer(sizeof(VertexData) * info.modelData.vertices.size());
  vbv_.BufferLocation = vb_->GetGPUVirtualAddress();
  vbv_.StrideInBytes = sizeof(VertexData);
  vbv_.SizeInBytes = UINT(sizeof(VertexData) * info.modelData.vertices.size());
  {
    void *ptr = nullptr;
    vb_->Map(0, nullptr, &ptr);
    std::memcpy(ptr, info.modelData.vertices.data(), vbv_.SizeInBytes);
  }

  // Material CB (PS: b0) — シェーダ側のレイアウトに一致
  // color / enableLighting /
  // uvTransform。:contentReference[oaiinfote:4]{index=4}
  cbMaterial_ = CreateUploadBuffer(Align256(sizeof(Material)));
  cbMaterial_->Map(0, nullptr, reinterpret_cast<void **>(&cbMatMapped_));
  *cbMatMapped_ = {};
  cbMatMapped_->color = info.baseColor;
  cbMatMapped_->enableLighting = info.lightingMode;
  cbMatMapped_->uvTransform = MakeIdentity4x4();

  // Transform CB (VS: b0) — WVP &
  // World。:contentReference[oaiinfote:5]{index=5}

  cbTransform_ = CreateUploadBuffer(Align256(sizeof(Transformation)));
  cbTransform_->Map(0, nullptr, reinterpret_cast<void **>(&cbTransMapped_));
  *cbTransMapped_ = {MakeIdentity4x4(), MakeIdentity4x4()};

  // Texture (PS: t0)
  if (!info.modelData.material.textureFilePath.empty()) {
    tex_ =
        resourceManager_->LoadTexture(info.modelData.material.textureFilePath);
    // GPUハンドル取得
    // ResourceManager内部でキャッシュしてるindexを利用する（戻り値でもOK）
    // ※仮。実際はResourceManager側で返却対応
    texHandleGPU_ = resourceManager_->GetGPUHandle(1);
  } else {
    // 空なら白1x1などを用意しても良い
  }

  return true;
}

void Model::SetColor(const Vector4 &color) { cbMatMapped_->color = color; }
void Model::SetLightingMode(int32_t mode) {
  cbMatMapped_->enableLighting =
      mode; // 0/1/2 に対応（PS分岐）。:contentReference[oaicite:6]{index=6}
}
void Model::SetUVTransform(const Matrix4x4 &uv) {
  cbMatMapped_->uvTransform = uv;
}
void Model::SetWorldTransform(const Matrix4x4 &world) { world_ = world; }

void Model::Draw(const Matrix4x4 &view, const Matrix4x4 &proj,
                 ID3D12Resource *directionalLightCB) {
  ID3D12GraphicsCommandList *cmd = dx_->GetCommandList();

  assert(tex_ != 0);                    // GPUハンドルが空じゃない
  assert(dx_->GetSRVHeap() != nullptr); // ヒープがある

  // PSO / RootSig
  cmd->SetPipelineState(pipeline_->GetPipelineState());
  cmd->SetGraphicsRootSignature(pipeline_->GetRootSignature());

  // IA
  cmd->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
  cmd->IASetVertexBuffers(0, 1, &vbv_);

  // 変換行列（VS:b0）
  Matrix4x4 wvp = Multiply(world_, Multiply(view, proj));
  cbTransMapped_->WVP = wvp;
  cbTransMapped_->World = world_;
  cmd->SetGraphicsRootConstantBufferView(1,
                                         cbTransform_->GetGPUVirtualAddress());
  //           ↑ MakeObject3DDesc の “VS: b0” 構成準拠（RootParam順は PS:b0,
  //           VS:b0, SRV table, PS:b1）
  //             UnifiedPipeline
  //             で詰めた順序に合わせる。:contentReference[oaicite:7]{index=7}

  // マテリアル（PS:b0）
  cmd->SetGraphicsRootConstantBufferView(0,
                                         cbMaterial_->GetGPUVirtualAddress());

  // テクスチャ（PS: t0）
  ID3D12DescriptorHeap *heaps[] = {dx_->GetSRVHeap()};
  cmd->SetDescriptorHeaps(1, heaps);
  cmd->SetGraphicsRootDescriptorTable(2, texHandleGPU_);

  // 平行光（PS:b1）
  if (directionalLightCB) {
    cmd->SetGraphicsRootConstantBufferView(
        3, directionalLightCB->GetGPUVirtualAddress());
  }

  // ビューポート/シザー（共通設定をそのまま利用）
  cmd->RSSetViewports(1, &dx_->GetViewport());
  cmd->RSSetScissorRects(1, &dx_->GetScissorRect());

  // Draw（インデックス無しの想定。必要ならIB追加して DrawIndexed）
  cmd->DrawInstanced(UINT(vbv_.SizeInBytes / vbv_.StrideInBytes), 1, 0, 0);
}

Microsoft::WRL::ComPtr<ID3D12Resource> Model::CreateUploadBuffer(size_t size) {
  auto device = dx_->GetDevice();
  ComPtr<ID3D12Resource> res;
  D3D12_HEAP_PROPERTIES heapProps{};
  heapProps.Type = D3D12_HEAP_TYPE_UPLOAD;

  D3D12_RESOURCE_DESC desc{};
  desc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
  desc.Width = size;
  desc.Height = 1;
  desc.DepthOrArraySize = 1;
  desc.MipLevels = 1;
  desc.SampleDesc.Count = 1;
  desc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

  HRESULT hr = device->CreateCommittedResource(
      &heapProps, D3D12_HEAP_FLAG_NONE, &desc,
      D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(&res));
  assert(SUCCEEDED(hr));
  return res;
}


